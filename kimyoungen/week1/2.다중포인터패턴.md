# Multiple Pointers 다중 포인터

## 문제1 (예시)

Write a function called **sumZero** which accepts a **sorted** array of integers. The function should find the **first** pair where the sum is 0. Return an array that includes both values that sum to zero or undefined if a pair does not exist.

## 내 풀이1 => 틀림

```
function sumZero(array){
  let left = 0
  let right = array.length-1

  for(number of array){
    if(number === array[right]){
      return [number, array[right]]
    }
    if(left >= right ){
      return undefined
    }
    firstIndex += 1
    lastIndex -= 1
  }

}
```

## naive 풀이1

시간 복잡도 : O(N^2) // 공간 복잡도 : O(1)

```
function sumZero(arr){
  for(let i = 0; i < arr.length ; i++){
    for(let j = i + 1; j < arr.length; j++){
      if(arr[i] + arr[j] === 0){
        return [ arr[i], arr[j]]
      }
    }
  }
}

```

## 수정된 내 풀이1 - by Claude / 답안 풀이1

시간 복잡도: O(n) // 공간 복잡도: O(1)

1. 반복문 접근 방식

- 나의 코드: for...of 루프 사용
- 수정된 코드: while 루프 사용 (투 포인터 전략에 더 적합)

2. 포인터 이동 로직

- 나의 코드: 복잡하고 직관적이지 않은 포인터 이동
- 수정된 코드: 합의 크기에 따라 명확하게 포인터 이동

3. 종료 조건

- 나의 코드: 불완전한 종료 조건
- 수정된 코드: left < right를 통해 명확한 탐색 범위 설정

```
function sumZero(arr) {
  // 첫 번째 포인터
  let left = 0;
  // 마지막 포인터
  let right = arr.length - 1;

  // left가 right보다 작은 동안 계속 탐색
  while (left < right) {
    // 두 포인터의 합 계산
    let sum = arr[left] + arr[right];

    // 합이 0이면 해당 쌍 반환
    if (sum === 0) {
      return [arr[left], arr[right]];
    }
    // 합이 0보다 크면 오른쪽 포인터를 왼쪽으로
    else if (sum > 0) {
      right--;
    }
    // 합이 0보다 작으면 왼쪽 포인터를 오른쪽으로
    else {
      left++;
    }
  }

  // 쌍을 찾지 못하면 undefined 반환
  return undefined;
}
```

